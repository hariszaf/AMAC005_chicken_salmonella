# Data preparation

### Sample metadata

```{r load_sample_metadata, message=FALSE, eval=FALSE}
sample_metadata <- read_csv("microbetag_analysis/data/sample_metadata_corrected.csv")
```

### Genome metadata
Relevant metadata of genomes is fetched from 2-3 files and merged into one genome metadata object for downstream analyses.

#### Dereplicated genomes

Bins were initially dereplicated at 99%, and annotations generated for all resulting MAGs. A second dereplication was performed at 95% to yield species-representative genomes. This analysis is performed on that subset. The list of selected genomes is stored in the `Wdb` file generated by dRep. 

```{r dereplicated_genomes, message=FALSE, eval=FALSE}
selected_genomes <- read_csv("data/Wdb.csv") %>% 
  mutate(genome=str_replace_all(genome,"\\.fa", "")) %>% 
  pull(genome)
length(selected_genomes)
```

The dereplication yielded 223 species-representative genomes.

#### Taxonomy
This is the raw taxonomy table generated by GTDBtk, which is simplified for downstream analyses.
```{r load_taxonomy, message=FALSE, eval=FALSE}
genome_taxonomy <- read_tsv("data/gtdbtk.summary.tsv") %>%
  rename(genome = user_genome) %>%
  mutate(genome = str_replace_all(genome,"\\.fa", "")) %>%
  # Filter only selected genomes (the 223 species-representatives)
  filter(genome %in% selected_genomes) %>% 
  separate(classification, c("domain","phylum","class","order","family","genus","species"),  sep =";") %>%
  select(genome,domain,phylum,class,order,family,genus,species)
```

#### Genome quality

The `genomeInfo.csv` outputed by dRep contains the genome quality information.


```{r load_quality, message=FALSE, eval=FALSE}
genome_quality <- read_csv("data/genomeInfo.csv") %>%
  mutate(genome = str_remove(genome, "\\.fa$")) %>%
  # Filter only selected genomes (the 223 species-representatives)
  filter(genome %in% selected_genomes) %>% 
  select(genome, completeness, contamination, length)
```

#### Merged metadata object
Merge taxonomy, length and quality information
```{r create_genomemetadata, message=FALSE, eval=FALSE}
genome_metadata <- genome_taxonomy %>%
  left_join(genome_quality,by="genome") #join quality
```

### Count table
This is the document containing the number of sequencing reads from each sample have been mapped to each MAG. Note that this is the raw data that needs to be further processed before running any statistics on them.

```{r load_count, message=FALSE, eval=FALSE}
read_counts <- read_tsv("data/coverm_genome_REF0015-g_mg_hybrid.0.95.count.tsv") %>%
  rename_all(~ str_remove_all(., ".lib1")) %>% #simplify column names
  rename(genome = 1) %>%
    select(all_of(c("genome",sample_metadata$sample))) %>% # sort samples
    arrange(match(genome,genome_metadata$genome)) # sort genomes
```

### Base hit table
This is the document containing the number of nucleotide bases have been covered by at least one read in each sample and MAG. This information is used to calculate MAG coverage values.

```{r load_hits, message=FALSE, eval=FALSE}
basehits <- read_tsv("data/coverm_genome_REF0015-g_mg_hybrid.0.95.covered_bases.tsv") %>%
  rename_all(~ str_remove_all(., ".lib1")) %>% #simplify column names
  rename(genome = 1) %>%
    select(all_of(c("genome",sample_metadata$sample))) %>% # sort samples
    arrange(match(genome,genome_metadata$genome)) # sort genomes
```

### Genome tree
This is the raw tree generated by GTDBtk, which needs to be pruned to obtain the phylogenetic tree of the genomes. Note that the archaeal tree is only generated if any archaeans are detected among the genomes.

```{r load_tree, message=FALSE, warning=FALSE, eval=FALSE}
genome_tree <- read.tree("data/gtdbtk.backbone.bac120.classify.tree")
genome_tree$tip.label <- str_replace_all(genome_tree$tip.label,"'", "") #remove single quotes in MAG names
genome_tree <- keep.tip(genome_tree, tip=selected_genomes) # keep only MAG tips
```

### MAG functional annotations
This is the raw annotation table generated by DRAM, which is used to generate GIFT data using distillR.
```{r load_annotations, message=FALSE, eval=FALSE}
genome_annotations <- read_tsv("data/annotations.tsv.xz") %>%
  rename(gene=1,genome=2)

total_genes <- genome_annotations %>%
  nrow()

unanotated_genes <- genome_annotations %>%
  filter(is.na(ko_id) & is.na(pfam_hits) & is.na(cazy_ids)) %>% 
  nrow()

annotated_genes <- total_genes - unanotated_genes

#Annotated percentage
annotated_genes / total_genes
```

## Filter and normalise data
Raw data needs to be filtered and normalised to make it useful for downstream analyses. 

### Generate coverage table
By dividing the number of base hits by the length of each genome, coverage values can be calculated.

```{r calc_coverage, eval=FALSE}
genome_coverage <- basehits %>%
  mutate(across(where(is.numeric), ~ ./genome_metadata$length))
```

### Coverage filtering
Genomes that have less than 30% of their length covered by reads are turned into zeros to account for the random allocation of reads across genomes due to mapping heuristics. 

```{r filter_coverage, eval=FALSE}
min_coverage=0.3
read_counts_filt <- genome_coverage %>%
  mutate(across(where(is.numeric), ~ ifelse(. > min_coverage, 1, 0))) %>%
  mutate(across(-1, ~ . * read_counts[[cur_column()]])) 
```

### Generate genome count table
After filtering the low-coverage reads, read counts are transformed into genome counts using genome-length and read-length information.

```{r calc_genometable, eval=FALSE}
readlength=150 #change if sequencing read length is different

genome_counts <- read_counts %>%
  mutate(across(where(is.numeric), ~ . / (genome_metadata$length / readlength) ))

genome_counts_filt <- read_counts_filt %>%
  mutate(across(where(is.numeric), ~ . / (genome_metadata$length / readlength) ))
```

### Distil functional annotations
Raw functional annotations are distilled into genome-inferred functional traits to generate biologically more meaningful functional traits for downstream analyses.

```{r distill_annotations, warning=FALSE, comments="", message=FALSE, results='hide', eval=FALSE}
genome_gifts <- distill(genome_annotations, GIFT_db, genomecol=2, annotcol=c(9,10,19))
```

## Color scheme

[AlberdiLab](www.alberdilab.dk) projects use unified color schemes developed for the [Earth Hologenome Initiative](www.earthhologenome.org), to facilitate figure interpretation.

```{r get_ehi_colors, warning=FALSE, comments="", message=FALSE, eval=FALSE}
phylum_colors <- read_tsv("https://raw.githubusercontent.com/earthhologenome/EHI_taxonomy_colour/main/ehi_phylum_colors.tsv") %>%
    right_join(genome_metadata, by=join_by(phylum == phylum)) %>%
    arrange(match(genome, genome_tree$tip.label)) %>%
    select(phylum, colors) %>% 
    unique() %>%
    arrange(phylum) %>%
    pull(colors, name=phylum)

# order_colors <- c(
#   "#08D1D1","#BF7022","#2EBC82","#2E91BC","#2E5ABC","#09CE8D","#E0A608","#097265","#AB56D8","#0AA01F","#274945","#4E397A","#B3265B",
#   "#2EBC45","#7F4561","#58BC2E","#BC2EA1","#6A52C6","#AD8D8D")
# 
# 
# treatment_colors <- c(TG1="#4059AE",TG2="#6A9AC3",TG3="#97D8C4",TG4="#AFD699",TG5="#F3B942")
```


## Wrap working objects
In the last step, the objects that are needed for downstream analyses are stored in an R object.

```{r wrap_objects, eval=FALSE}
save(read_counts, 
     read_counts_filt, 
     genome_counts, 
     genome_counts_filt, 
     genome_tree, 
     genome_metadata, 
     genome_gifts, 
     sample_metadata, 
     phylum_colors,
     order_colors,
     treatment_colors, file = "data/data.Rdata")
```

- **read_counts**: Number of reads mapped to each genome in each sample. Note this is the unfiltered and unnormalised raw community composition table.
- **genome_counts**: Number of genomes quantified in each sample, calculated through filtering and normalising ***read_counts***. This is the community composition table to be used in downstream analyses unless otherwise stated.
- **genome_tree**: Phylogenetic tree of the genomes, to be employed in downstream phylogenetic analyses.
- **genome_metadata**: Taxonomic and quality information of the genomes.
- **genome_gifts**: Genome-inferred functional traits of the genomes, to be employed in downstream functional analyses.
- **sample_metadata**: Treatment/population and other relevant metadata of the samples.
  
